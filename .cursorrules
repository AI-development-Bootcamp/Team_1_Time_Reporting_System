
## Project Context
- **Architecture**: Monorepo with three main services: `backend` (Express), `frontend_user` (Mobile-first React), and `frontend_admin` (Web-first React).
- **Core Stack**: TypeScript, Prisma (PostgreSQL), Mantine UI, Vitest, Zod.
- **Key Constraints**: Hebrew RTL interface, soft deletes for users, binary file storage (Bytes) in DB.

## ⚠️ CRITICAL: Do NOT Make Changes Without Permission
- **DO NOT** add fields to data models/interfaces without explicit permission
- **DO NOT** add API versioning (e.g., `/api/v1/`) without explicit permission
- **DO NOT** add new features, patterns, or architectural changes without asking first
- **ALWAYS** ask before making structural changes that weren't explicitly requested
- When in doubt, **ASK** - do not assume or "improve" without permission

## Role & Instructions
You are an expert full-stack developer specializing in TypeScript. Follow these rules strictly:

### 1. Monorepo Workflow
- Always verify which directory you are working in before creating files.
- `backend/`: Node.js/Express logic, Prisma schemas, and migrations.
- `frontend_user/`: Mobile-optimized React code.
- `frontend_admin/`: Desktop-optimized React code.
- Use the root `package.json` scripts (`npm run dev:all`, etc.) for orchestration.

### 2. Frontend Development (React + Mantine)
- **UI/UX**: Use **Mantine UI** components exclusively.
- **RTL**: All layouts must support **Hebrew (RTL)**. Ensure the `MantineProvider` is configured with `direction: 'rtl'`.
- **Design Priority**: 
  - `frontend_user`: Prioritize responsive, touch-friendly components.
  - `frontend_admin`: Prioritize data density and table-based views.
- **Date Handling Rule (Crucial for Day.js)**: Always use Day.js for date manipulations. Do not use the native Date object for calculations. When interacting with the DB, convert Day.js objects to ISO strings or Javascript Date objects as required by Prisma.
- **State Management Rule (TanStack Query)**: Use TanStack Query hooks (useQuery, useMutation) for all server data fetching. Do not use useEffect + axios manually in components. Always invalidate queries after a mutation.
- **Form Rule (Mantine Form)**: When building forms, use the useForm hook from @mantine/form and pass the form.getInputProps('fieldName') directly to Mantine components.

### 3. Backend Development (Express + Prisma)
- **Type Safety**: Use **Zod** for all request body and query parameter validation.
- **Database**: Use Prisma Client for all DB interactions. 
- **Soft Deletes**: When "deleting" a User, set `active = false` instead of removing the record. Always filter for `active: true` in standard queries.
- **Files**: Store absence files as `Bytes` in PostgreSQL via Prisma. Use Multer for multipart handling.
- **Logic**: 
  - Validation: Block entries where `EndTime < StartTime`.
  - Timer: Ensure the auto-stop logic at `23:59` is handled (saves with `work` status).

### 4. Technical Standards
- **TypeScript**: No `any` type. Define interfaces for all API responses and data models.
- **Testing**: Write unit tests in **Vitest**. Target 60% coverage.
- **Performance**: 
  - API responses for core actions (login, time entry) must be < 500ms.
- **Auth**: Use JWT with 24h expiry. Protect routes using a shared auth middleware.

### 5. Code Style & Conventions
- **CSS Rule**: **No inline styles** are permitted in components (avoid `style={{...}}`).
- Use functional components and React Hooks.
- Prefer `const` over `let`.
- **Variable Naming**: Use `camelCase` for all variables, functions, and instances (e.g., `userReport`, `fetchProjectData`).
- **Components**: PascalCase (e.g., `ExpenseForm`, `CategorySummary`)
- **Files**: PascalCase for all files in folders (e.g., `ExpenseForm.tsx`, `ExpenseTypes.ts`, `FormatCurrency.ts`)
- **Functions/Variables**: camelCase (e.g., `handleSubmit`, `totalAmount`)
- **Constants**: UPPER_SNAKE_CASE (e.g., `EXPENSE_CATEGORIES`)
- **Types/Interfaces**: PascalCase with descriptive names (e.g., `Expense`, `ExpenseFormData`)

## Project Structure Reference
- `/backend/src`: Controllers, Services, Middlewares, Routes.
- `/backend/prisma/schema.prisma`: Source of truth for models.
- `/frontend_user/src/components`: Mobile-specific components.
- `/frontend_admin/src/components`: Admin-specific dashboards.

## Common Patterns

### Backend API Pattern
```typescript
// Always use Zod for validation
import { z } from 'zod';

const createReportSchema = z.object({
  startTime: z.string(),
  endTime: z.string(),
  // ... other fields
});


```

### Frontend Component Pattern
```typescript
// Always use Mantine components, no inline styles
import { Button, TextInput } from '@mantine/core';

// RTL support via MantineProvider
<MantineProvider theme={{ dir: 'rtl' }}>
  {/* components */}
</MantineProvider>
```

### Date Handling Pattern (Day.js)
```typescript
import dayjs from 'dayjs';

// Always use Day.js for date calculations
const today = dayjs();
const startOfMonth = dayjs().startOf('month');
const formattedDate = dayjs(date).format('DD/MM/YY');

// Convert to Date/ISO for Prisma
const prismaDate = dayjs(date).toDate(); // or .toISOString()
```

### State Management Pattern (TanStack Query)
```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';

// Fetching data
const { data, isLoading } = useQuery({
  queryKey: ['reports', month],
  queryFn: () => fetchReports(month)
});

// Mutations with query invalidation
const queryClient = useQueryClient();
const mutation = useMutation({
  mutationFn: createReport,
  onSuccess: () => {
    queryClient.invalidateQueries({ queryKey: ['reports'] });
  }
});
```

```typescript
import { useForm } from '@mantine/form';
import { TextInput, Button } from '@mantine/core';

const form = useForm({
  initialValues: {
    email: '',
    name: ''
  }
});

// Pass getInputProps directly to Mantine components
<TextInput {...form.getInputProps('email')} />
<TextInput {...form.getInputProps('name')} />
```

---

## Architecture Compliance (CRITICAL)

### Backend Three-Layer Architecture
**ALWAYS** follow this pattern for new features:
```
Routes (HTTP) → Controllers (Validation) → Services (Business Logic)
```

- **Routes**: Thin route definitions only (`routes/` and `routes/admin/`)
  - Only define endpoints and apply middleware
  - Immediately delegate to controllers
  - No business logic, no database queries
  
- **Controllers**: HTTP request handling (`controllers/`)
  - Parse request parameters
  - Validate with Zod schemas from `validators/`
  - Call service methods
  - Return responses using `ApiResponse` utility
  - Use try/catch with `next(error)` for error handling
  
- **Services**: Business logic and database access (`services/`)
  - All Prisma queries go here
  - All business logic and validation
  - Throw `AppError` for error conditions
  - NO HTTP concerns (req, res, next)

**Example Pattern**:
```typescript
// routes/admin/users.ts
router.post('/users', UserController.createUser);

// controllers/UserController.ts
static async createUser(req: Request, res: Response, next: NextFunction) {
  try {
    const validatedData = createUserSchema.parse(req.body);
    const result = await UserService.createUser(validatedData);
    ApiResponse.success(res, result, 201);
  } catch (error) {
    next(error);
  }
}

// services/UserService.ts
static async createUser(data: CreateUserInput) {
  // Check business rules, query database, etc.
  const user = await prisma.user.create({ data });
  return { id: Number(user.id) };
}
```

### Frontend Path Aliases
**ALWAYS** use path aliases for imports:
```typescript
// ✅ CORRECT
import { UserTable } from '@components/Users/UserTable';
import { useUsers } from '@hooks/useUsers';
import { apiClient } from '@shared/utils/ApiClient';

// ❌ WRONG
import { UserTable } from '../../components/Users/UserTable';
import { useUsers } from '../hooks/useUsers';
```

Available aliases: `@/`, `@components/`, `@hooks/`, `@pages/`, `@services/`, `@types/`, `@utils/`, `@shared/`

### Validation
- **ALWAYS** create Zod schemas in `validators/` directory
- **NEVER** put validation logic in controllers or services
- Reuse schemas across endpoints when possible

### Authentication & JWT
- Use existing `ApiClient` interceptor for auth headers (already configured)
- JWT flow: Backend generates → Frontend stores in localStorage → Auto-attached to requests → Backend verifies
- **DO NOT** create new auth logic - use `AuthContext` and `authMiddleware`
- Token is stored as `localStorage.getItem('token')`
- Password requirements: 8 chars min, 1 uppercase, 1 lowercase, 1 special char

### Critical Rules
- **NO inline business logic in routes/controllers** - always use services
- **NO direct Prisma queries in controllers** - always use services  
- **NO duplicate code** - create reusable services/utilities
- **ALWAYS** follow the existing pattern when adding new features

### Password Validation
All password fields must meet these requirements:
- Minimum 8 characters
- At least 1 uppercase letter (A-Z)
- At least 1 lowercase letter (a-z)
- At least 1 special character (@$!%*?&)

Regex pattern: `/^(?=.*[a-z])(?=.*[A-Z])(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$/`

